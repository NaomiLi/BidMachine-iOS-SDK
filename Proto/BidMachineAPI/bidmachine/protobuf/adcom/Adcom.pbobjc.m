// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bidmachine/protobuf/adcom/adcom.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "bidmachine/protobuf/adcom/Adcom.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ADCOMAdcomRoot

@implementation ADCOMAdcomRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ADCOMAdcomRoot_FileDescriptor

static GPBFileDescriptor *ADCOMAdcomRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"bidmachine.protobuf.adcom"
                                                 objcPrefix:@"ADCOM"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ADCOMAuditStatusCode

GPBEnumDescriptor *ADCOMAuditStatusCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AuditStatusCodeInvalid\000AuditStatusCodePe"
        "ndingAudit\000AuditStatusCodePreApproved\000Au"
        "ditStatusCodeApproved\000AuditStatusCodeDen"
        "ied\000AuditStatusCodeChanged\000";
    static const int32_t values[] = {
        ADCOMAuditStatusCode_AuditStatusCodeInvalid,
        ADCOMAuditStatusCode_AuditStatusCodePendingAudit,
        ADCOMAuditStatusCode_AuditStatusCodePreApproved,
        ADCOMAuditStatusCode_AuditStatusCodeApproved,
        ADCOMAuditStatusCode_AuditStatusCodeDenied,
        ADCOMAuditStatusCode_AuditStatusCodeChanged,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMAuditStatusCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMAuditStatusCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMAuditStatusCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMAuditStatusCode_AuditStatusCodeInvalid:
    case ADCOMAuditStatusCode_AuditStatusCodePendingAudit:
    case ADCOMAuditStatusCode_AuditStatusCodePreApproved:
    case ADCOMAuditStatusCode_AuditStatusCodeApproved:
    case ADCOMAuditStatusCode_AuditStatusCodeDenied:
    case ADCOMAuditStatusCode_AuditStatusCodeChanged:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMApiFramework

GPBEnumDescriptor *ADCOMApiFramework_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ApiFrameworkInvalid\000ApiFrameworkVpaid10\000"
        "ApiFrameworkVpaid20\000ApiFrameworkMraid10\000"
        "ApiFrameworkOrmma\000ApiFrameworkMraid20\000Ap"
        "iFrameworkMraid30\000ApiFrameworkOmid10\000";
    static const int32_t values[] = {
        ADCOMApiFramework_ApiFrameworkInvalid,
        ADCOMApiFramework_ApiFrameworkVpaid10,
        ADCOMApiFramework_ApiFrameworkVpaid20,
        ADCOMApiFramework_ApiFrameworkMraid10,
        ADCOMApiFramework_ApiFrameworkOrmma,
        ADCOMApiFramework_ApiFrameworkMraid20,
        ADCOMApiFramework_ApiFrameworkMraid30,
        ADCOMApiFramework_ApiFrameworkOmid10,
    };
    static const char *extraTextFormatInfo = "\006\001c\351\345\201\201\000\002c\351\345\201\201\000\003c\351\345\201\201\000\005c\351\345\201\201\000\006c\351\345\201\201\000\007c\351\344\201\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMApiFramework)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMApiFramework_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMApiFramework_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMApiFramework_ApiFrameworkInvalid:
    case ADCOMApiFramework_ApiFrameworkVpaid10:
    case ADCOMApiFramework_ApiFrameworkVpaid20:
    case ADCOMApiFramework_ApiFrameworkMraid10:
    case ADCOMApiFramework_ApiFrameworkOrmma:
    case ADCOMApiFramework_ApiFrameworkMraid20:
    case ADCOMApiFramework_ApiFrameworkMraid30:
    case ADCOMApiFramework_ApiFrameworkOmid10:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMCategoryTaxonomy

GPBEnumDescriptor *ADCOMCategoryTaxonomy_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CategoryTaxonomyInvalid\000CategoryTaxonomy"
        "IabContent10\000CategoryTaxonomyIabContent2"
        "0\000CategoryTaxonomyIabAdProduct10\000";
    static const int32_t values[] = {
        ADCOMCategoryTaxonomy_CategoryTaxonomyInvalid,
        ADCOMCategoryTaxonomy_CategoryTaxonomyIabContent10,
        ADCOMCategoryTaxonomy_CategoryTaxonomyIabContent20,
        ADCOMCategoryTaxonomy_CategoryTaxonomyIabAdProduct10,
    };
    static const char *extraTextFormatInfo = "\003\001h\350\343\347\201\201\000\002h\350\343\347\201\201\000\003h\350\343\342\347\201\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMCategoryTaxonomy)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMCategoryTaxonomy_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMCategoryTaxonomy_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMCategoryTaxonomy_CategoryTaxonomyInvalid:
    case ADCOMCategoryTaxonomy_CategoryTaxonomyIabContent10:
    case ADCOMCategoryTaxonomy_CategoryTaxonomyIabContent20:
    case ADCOMCategoryTaxonomy_CategoryTaxonomyIabAdProduct10:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMClickType

GPBEnumDescriptor *ADCOMClickType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ClickTypeNonClickable\000ClickTypeClickable"
        "Unknown\000ClickTypeClickableEmbeddedBrowse"
        "r\000ClickTypeClickableNativeBrowser\000";
    static const int32_t values[] = {
        ADCOMClickType_ClickTypeNonClickable,
        ADCOMClickType_ClickTypeClickableUnknown,
        ADCOMClickType_ClickTypeClickableEmbeddedBrowser,
        ADCOMClickType_ClickTypeClickableNativeBrowser,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMClickType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMClickType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMClickType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMClickType_ClickTypeNonClickable:
    case ADCOMClickType_ClickTypeClickableUnknown:
    case ADCOMClickType_ClickTypeClickableEmbeddedBrowser:
    case ADCOMClickType_ClickTypeClickableNativeBrowser:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMCompanionType

GPBEnumDescriptor *ADCOMCompanionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CompanionTypeInvalid\000CompanionTypeStatic"
        "Resource\000CompanionTypeHtmlResource\000Compa"
        "nionTypeIframeResource\000";
    static const int32_t values[] = {
        ADCOMCompanionType_CompanionTypeInvalid,
        ADCOMCompanionType_CompanionTypeStaticResource,
        ADCOMCompanionType_CompanionTypeHtmlResource,
        ADCOMCompanionType_CompanionTypeIframeResource,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMCompanionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMCompanionType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMCompanionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMCompanionType_CompanionTypeInvalid:
    case ADCOMCompanionType_CompanionTypeStaticResource:
    case ADCOMCompanionType_CompanionTypeHtmlResource:
    case ADCOMCompanionType_CompanionTypeIframeResource:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMConnectionType

GPBEnumDescriptor *ADCOMConnectionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ConnectionTypeInvalid\000ConnectionTypeEthe"
        "rnet\000ConnectionTypeWifi\000ConnectionTypeCe"
        "llularNetworkUnknown\000ConnectionTypeCellu"
        "larNetwork2G\000ConnectionTypeCellularNetwo"
        "rk3G\000ConnectionTypeCellularNetwork4G\000Con"
        "nectionTypeCellularNetwork5G\000";
    static const int32_t values[] = {
        ADCOMConnectionType_ConnectionTypeInvalid,
        ADCOMConnectionType_ConnectionTypeEthernet,
        ADCOMConnectionType_ConnectionTypeWifi,
        ADCOMConnectionType_ConnectionTypeCellularNetworkUnknown,
        ADCOMConnectionType_ConnectionTypeCellularNetwork2G,
        ADCOMConnectionType_ConnectionTypeCellularNetwork3G,
        ADCOMConnectionType_ConnectionTypeCellularNetwork4G,
        ADCOMConnectionType_ConnectionTypeCellularNetwork5G,
    };
    static const char *extraTextFormatInfo = "\004\004j\344\350\347\202\000\005j\344\350\347\202\000\006j\344\350\347\202\000\007j\344\350\347\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMConnectionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMConnectionType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMConnectionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMConnectionType_ConnectionTypeInvalid:
    case ADCOMConnectionType_ConnectionTypeEthernet:
    case ADCOMConnectionType_ConnectionTypeWifi:
    case ADCOMConnectionType_ConnectionTypeCellularNetworkUnknown:
    case ADCOMConnectionType_ConnectionTypeCellularNetwork2G:
    case ADCOMConnectionType_ConnectionTypeCellularNetwork3G:
    case ADCOMConnectionType_ConnectionTypeCellularNetwork4G:
    case ADCOMConnectionType_ConnectionTypeCellularNetwork5G:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMContentContext

GPBEnumDescriptor *ADCOMContentContext_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ContentContextInvalid\000ContentContextVide"
        "o\000ContentContextGame\000ContentContextMusic"
        "\000ContentContextApplication\000ContentContex"
        "tText\000ContentContextOther\000ContentContext"
        "Unknown\000";
    static const int32_t values[] = {
        ADCOMContentContext_ContentContextInvalid,
        ADCOMContentContext_ContentContextVideo,
        ADCOMContentContext_ContentContextGame,
        ADCOMContentContext_ContentContextMusic,
        ADCOMContentContext_ContentContextApplication,
        ADCOMContentContext_ContentContextText,
        ADCOMContentContext_ContentContextOther,
        ADCOMContentContext_ContentContextUnknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMContentContext)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMContentContext_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMContentContext_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMContentContext_ContentContextInvalid:
    case ADCOMContentContext_ContentContextVideo:
    case ADCOMContentContext_ContentContextGame:
    case ADCOMContentContext_ContentContextMusic:
    case ADCOMContentContext_ContentContextApplication:
    case ADCOMContentContext_ContentContextText:
    case ADCOMContentContext_ContentContextOther:
    case ADCOMContentContext_ContentContextUnknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMCreativeAttribute

GPBEnumDescriptor *ADCOMCreativeAttribute_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CreativeAttributeInvalid\000CreativeAttribu"
        "teAudioAdAutoplay\000CreativeAttributeAudio"
        "AdUserInitiated\000CreativeAttributeExpanda"
        "bleAutomatic\000CreativeAttributeExpandable"
        "UserInitiatedClick\000CreativeAttributeExpa"
        "ndableUserInitiatedRollover\000CreativeAttr"
        "ibuteInBannerVideoAdAutoplay\000CreativeAtt"
        "ributeInBannerVideoAdUserInitiated\000Creat"
        "iveAttributePop\000CreativeAttributeProvoca"
        "tiveSuggestiveImagery\000CreativeAttributeE"
        "xtremeAnimation\000CreativeAttributeSurveys"
        "\000CreativeAttributeTextOnly\000CreativeAttri"
        "buteUserInteractive\000CreativeAttributeAle"
        "rtStyle\000CreativeAttributeHasAudioOnOffBu"
        "tton\000CreativeAttributeAdProvidesSkipButt"
        "on\000CreativeAttributeAdobeFlash\000CreativeA"
        "ttributeResponsive\000";
    static const int32_t values[] = {
        ADCOMCreativeAttribute_CreativeAttributeInvalid,
        ADCOMCreativeAttribute_CreativeAttributeAudioAdAutoplay,
        ADCOMCreativeAttribute_CreativeAttributeAudioAdUserInitiated,
        ADCOMCreativeAttribute_CreativeAttributeExpandableAutomatic,
        ADCOMCreativeAttribute_CreativeAttributeExpandableUserInitiatedClick,
        ADCOMCreativeAttribute_CreativeAttributeExpandableUserInitiatedRollover,
        ADCOMCreativeAttribute_CreativeAttributeInBannerVideoAdAutoplay,
        ADCOMCreativeAttribute_CreativeAttributeInBannerVideoAdUserInitiated,
        ADCOMCreativeAttribute_CreativeAttributePop,
        ADCOMCreativeAttribute_CreativeAttributeProvocativeSuggestiveImagery,
        ADCOMCreativeAttribute_CreativeAttributeExtremeAnimation,
        ADCOMCreativeAttribute_CreativeAttributeSurveys,
        ADCOMCreativeAttribute_CreativeAttributeTextOnly,
        ADCOMCreativeAttribute_CreativeAttributeUserInteractive,
        ADCOMCreativeAttribute_CreativeAttributeAlertStyle,
        ADCOMCreativeAttribute_CreativeAttributeHasAudioOnOffButton,
        ADCOMCreativeAttribute_CreativeAttributeAdProvidesSkipButton,
        ADCOMCreativeAttribute_CreativeAttributeAdobeFlash,
        ADCOMCreativeAttribute_CreativeAttributeResponsive,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMCreativeAttribute)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMCreativeAttribute_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMCreativeAttribute_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMCreativeAttribute_CreativeAttributeInvalid:
    case ADCOMCreativeAttribute_CreativeAttributeAudioAdAutoplay:
    case ADCOMCreativeAttribute_CreativeAttributeAudioAdUserInitiated:
    case ADCOMCreativeAttribute_CreativeAttributeExpandableAutomatic:
    case ADCOMCreativeAttribute_CreativeAttributeExpandableUserInitiatedClick:
    case ADCOMCreativeAttribute_CreativeAttributeExpandableUserInitiatedRollover:
    case ADCOMCreativeAttribute_CreativeAttributeInBannerVideoAdAutoplay:
    case ADCOMCreativeAttribute_CreativeAttributeInBannerVideoAdUserInitiated:
    case ADCOMCreativeAttribute_CreativeAttributePop:
    case ADCOMCreativeAttribute_CreativeAttributeProvocativeSuggestiveImagery:
    case ADCOMCreativeAttribute_CreativeAttributeExtremeAnimation:
    case ADCOMCreativeAttribute_CreativeAttributeSurveys:
    case ADCOMCreativeAttribute_CreativeAttributeTextOnly:
    case ADCOMCreativeAttribute_CreativeAttributeUserInteractive:
    case ADCOMCreativeAttribute_CreativeAttributeAlertStyle:
    case ADCOMCreativeAttribute_CreativeAttributeHasAudioOnOffButton:
    case ADCOMCreativeAttribute_CreativeAttributeAdProvidesSkipButton:
    case ADCOMCreativeAttribute_CreativeAttributeAdobeFlash:
    case ADCOMCreativeAttribute_CreativeAttributeResponsive:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMDeliveryMethod

GPBEnumDescriptor *ADCOMDeliveryMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DeliveryMethodInvalid\000DeliveryMethodStre"
        "aming\000DeliveryMethodProgressive\000Delivery"
        "MethodDownload\000";
    static const int32_t values[] = {
        ADCOMDeliveryMethod_DeliveryMethodInvalid,
        ADCOMDeliveryMethod_DeliveryMethodStreaming,
        ADCOMDeliveryMethod_DeliveryMethodProgressive,
        ADCOMDeliveryMethod_DeliveryMethodDownload,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMDeliveryMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMDeliveryMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMDeliveryMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMDeliveryMethod_DeliveryMethodInvalid:
    case ADCOMDeliveryMethod_DeliveryMethodStreaming:
    case ADCOMDeliveryMethod_DeliveryMethodProgressive:
    case ADCOMDeliveryMethod_DeliveryMethodDownload:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMDeviceType

GPBEnumDescriptor *ADCOMDeviceType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DeviceTypeInvalid\000DeviceTypeMobile\000Devic"
        "eTypePhoneDevice\000DeviceTypeTablet\000";
    static const int32_t values[] = {
        ADCOMDeviceType_DeviceTypeInvalid,
        ADCOMDeviceType_DeviceTypeMobile,
        ADCOMDeviceType_DeviceTypePhoneDevice,
        ADCOMDeviceType_DeviceTypeTablet,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMDeviceType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMDeviceType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMDeviceType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMDeviceType_DeviceTypeInvalid:
    case ADCOMDeviceType_DeviceTypeMobile:
    case ADCOMDeviceType_DeviceTypePhoneDevice:
    case ADCOMDeviceType_DeviceTypeTablet:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMDisplayContextType

GPBEnumDescriptor *ADCOMDisplayContextType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DisplayContextTypeInvalid\000DisplayContext"
        "TypeContentCentricContext\000DisplayContext"
        "TypeArticleContent\000DisplayContextTypeVid"
        "eoContent\000DisplayContextTypeAudioContent"
        "\000DisplayContextTypeImageContent\000DisplayC"
        "ontextTypeUserGeneratedContent\000DisplayCo"
        "ntextTypeSocialCentricContext\000DisplayCon"
        "textTypeEmailContent\000DisplayContextTypeC"
        "hatContent\000DisplayContextTypeProductCont"
        "ext\000DisplayContextTypeAppStore\000DisplayCo"
        "ntextTypeProductReviews\000";
    static const int32_t values[] = {
        ADCOMDisplayContextType_DisplayContextTypeInvalid,
        ADCOMDisplayContextType_DisplayContextTypeContentCentricContext,
        ADCOMDisplayContextType_DisplayContextTypeArticleContent,
        ADCOMDisplayContextType_DisplayContextTypeVideoContent,
        ADCOMDisplayContextType_DisplayContextTypeAudioContent,
        ADCOMDisplayContextType_DisplayContextTypeImageContent,
        ADCOMDisplayContextType_DisplayContextTypeUserGeneratedContent,
        ADCOMDisplayContextType_DisplayContextTypeSocialCentricContext,
        ADCOMDisplayContextType_DisplayContextTypeEmailContent,
        ADCOMDisplayContextType_DisplayContextTypeChatContent,
        ADCOMDisplayContextType_DisplayContextTypeProductContext,
        ADCOMDisplayContextType_DisplayContextTypeAppStore,
        ADCOMDisplayContextType_DisplayContextTypeProductReviews,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMDisplayContextType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMDisplayContextType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMDisplayContextType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMDisplayContextType_DisplayContextTypeInvalid:
    case ADCOMDisplayContextType_DisplayContextTypeContentCentricContext:
    case ADCOMDisplayContextType_DisplayContextTypeArticleContent:
    case ADCOMDisplayContextType_DisplayContextTypeVideoContent:
    case ADCOMDisplayContextType_DisplayContextTypeAudioContent:
    case ADCOMDisplayContextType_DisplayContextTypeImageContent:
    case ADCOMDisplayContextType_DisplayContextTypeUserGeneratedContent:
    case ADCOMDisplayContextType_DisplayContextTypeSocialCentricContext:
    case ADCOMDisplayContextType_DisplayContextTypeEmailContent:
    case ADCOMDisplayContextType_DisplayContextTypeChatContent:
    case ADCOMDisplayContextType_DisplayContextTypeProductContext:
    case ADCOMDisplayContextType_DisplayContextTypeAppStore:
    case ADCOMDisplayContextType_DisplayContextTypeProductReviews:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMDisplayCreativeType

GPBEnumDescriptor *ADCOMDisplayCreativeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DisplayCreativeTypeInvalid\000DisplayCreati"
        "veTypeHtml\000DisplayCreativeTypeAmphtml\000Di"
        "splayCreativeTypeImageObject\000DisplayCrea"
        "tiveTypeNativeObject\000";
    static const int32_t values[] = {
        ADCOMDisplayCreativeType_DisplayCreativeTypeInvalid,
        ADCOMDisplayCreativeType_DisplayCreativeTypeHtml,
        ADCOMDisplayCreativeType_DisplayCreativeTypeAmphtml,
        ADCOMDisplayCreativeType_DisplayCreativeTypeImageObject,
        ADCOMDisplayCreativeType_DisplayCreativeTypeNativeObject,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMDisplayCreativeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMDisplayCreativeType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMDisplayCreativeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMDisplayCreativeType_DisplayCreativeTypeInvalid:
    case ADCOMDisplayCreativeType_DisplayCreativeTypeHtml:
    case ADCOMDisplayCreativeType_DisplayCreativeTypeAmphtml:
    case ADCOMDisplayCreativeType_DisplayCreativeTypeImageObject:
    case ADCOMDisplayCreativeType_DisplayCreativeTypeNativeObject:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMDisplayPlacementType

GPBEnumDescriptor *ADCOMDisplayPlacementType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "DisplayPlacementTypeInvalid\000DisplayPlace"
        "mentTypeInFeedDisplay\000DisplayPlacementTy"
        "peInAtomicUnit\000DisplayPlacementTypeOutsi"
        "deCoreContent\000DisplayPlacementTypeRecomm"
        "endationWidget\000";
    static const int32_t values[] = {
        ADCOMDisplayPlacementType_DisplayPlacementTypeInvalid,
        ADCOMDisplayPlacementType_DisplayPlacementTypeInFeedDisplay,
        ADCOMDisplayPlacementType_DisplayPlacementTypeInAtomicUnit,
        ADCOMDisplayPlacementType_DisplayPlacementTypeOutsideCoreContent,
        ADCOMDisplayPlacementType_DisplayPlacementTypeRecommendationWidget,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMDisplayPlacementType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMDisplayPlacementType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMDisplayPlacementType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMDisplayPlacementType_DisplayPlacementTypeInvalid:
    case ADCOMDisplayPlacementType_DisplayPlacementTypeInFeedDisplay:
    case ADCOMDisplayPlacementType_DisplayPlacementTypeInAtomicUnit:
    case ADCOMDisplayPlacementType_DisplayPlacementTypeOutsideCoreContent:
    case ADCOMDisplayPlacementType_DisplayPlacementTypeRecommendationWidget:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMExpandableDirection

GPBEnumDescriptor *ADCOMExpandableDirection_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ExpandableDirectionInvalid\000ExpandableDir"
        "ectionLeft\000ExpandableDirectionRight\000Expa"
        "ndableDirectionUp\000ExpandableDirectionDow"
        "n\000ExpandableDirectionFullScreen\000";
    static const int32_t values[] = {
        ADCOMExpandableDirection_ExpandableDirectionInvalid,
        ADCOMExpandableDirection_ExpandableDirectionLeft,
        ADCOMExpandableDirection_ExpandableDirectionRight,
        ADCOMExpandableDirection_ExpandableDirectionUp,
        ADCOMExpandableDirection_ExpandableDirectionDown,
        ADCOMExpandableDirection_ExpandableDirectionFullScreen,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMExpandableDirection)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMExpandableDirection_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMExpandableDirection_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMExpandableDirection_ExpandableDirectionInvalid:
    case ADCOMExpandableDirection_ExpandableDirectionLeft:
    case ADCOMExpandableDirection_ExpandableDirectionRight:
    case ADCOMExpandableDirection_ExpandableDirectionUp:
    case ADCOMExpandableDirection_ExpandableDirectionDown:
    case ADCOMExpandableDirection_ExpandableDirectionFullScreen:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMEventTrackingMethod

GPBEnumDescriptor *ADCOMEventTrackingMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EventTrackingMethodInvalid\000EventTracking"
        "MethodImagePixel\000EventTrackingMethodJava"
        "script\000";
    static const int32_t values[] = {
        ADCOMEventTrackingMethod_EventTrackingMethodInvalid,
        ADCOMEventTrackingMethod_EventTrackingMethodImagePixel,
        ADCOMEventTrackingMethod_EventTrackingMethodJavascript,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMEventTrackingMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMEventTrackingMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMEventTrackingMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMEventTrackingMethod_EventTrackingMethodInvalid:
    case ADCOMEventTrackingMethod_EventTrackingMethodImagePixel:
    case ADCOMEventTrackingMethod_EventTrackingMethodJavascript:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMEventType

GPBEnumDescriptor *ADCOMEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EventTypeInvalid\000EventTypeImpression\000Eve"
        "ntTypeViewableMrc50\000EventTypeViewableMrc"
        "100\000EventTypeViewableVideo50\000";
    static const int32_t values[] = {
        ADCOMEventType_EventTypeInvalid,
        ADCOMEventType_EventTypeImpression,
        ADCOMEventType_EventTypeViewableMrc50,
        ADCOMEventType_EventTypeViewableMrc100,
        ADCOMEventType_EventTypeViewableVideo50,
    };
    static const char *extraTextFormatInfo = "\003\002e\344\350\343\202\000\003e\344\350\343\203\000\004e\344\350\345\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMEventType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMEventType_EventTypeInvalid:
    case ADCOMEventType_EventTypeImpression:
    case ADCOMEventType_EventTypeViewableMrc50:
    case ADCOMEventType_EventTypeViewableMrc100:
    case ADCOMEventType_EventTypeViewableVideo50:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMIpLocationService

GPBEnumDescriptor *ADCOMIpLocationService_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IpLocationServiceInvalid\000IpLocationServi"
        "ceIp2Location\000IpLocationServiceNeustar\000I"
        "pLocationServiceMaxmind\000IpLocationServic"
        "eNetaquity\000";
    static const int32_t values[] = {
        ADCOMIpLocationService_IpLocationServiceInvalid,
        ADCOMIpLocationService_IpLocationServiceIp2Location,
        ADCOMIpLocationService_IpLocationServiceNeustar,
        ADCOMIpLocationService_IpLocationServiceMaxmind,
        ADCOMIpLocationService_IpLocationServiceNetaquity,
    };
    static const char *extraTextFormatInfo = "\001\001b\350\347\342\002g\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMIpLocationService)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMIpLocationService_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMIpLocationService_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMIpLocationService_IpLocationServiceInvalid:
    case ADCOMIpLocationService_IpLocationServiceIp2Location:
    case ADCOMIpLocationService_IpLocationServiceNeustar:
    case ADCOMIpLocationService_IpLocationServiceMaxmind:
    case ADCOMIpLocationService_IpLocationServiceNetaquity:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMLinearityMode

GPBEnumDescriptor *ADCOMLinearityMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LinearityModeInvalid\000LinearityModeLinear"
        "\000LinearityModeNonLinear\000";
    static const int32_t values[] = {
        ADCOMLinearityMode_LinearityModeInvalid,
        ADCOMLinearityMode_LinearityModeLinear,
        ADCOMLinearityMode_LinearityModeNonLinear,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMLinearityMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMLinearityMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMLinearityMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMLinearityMode_LinearityModeInvalid:
    case ADCOMLinearityMode_LinearityModeLinear:
    case ADCOMLinearityMode_LinearityModeNonLinear:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMLocationType

GPBEnumDescriptor *ADCOMLocationType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "LocationTypeInvalid\000LocationTypeGps\000Loca"
        "tionTypeIp\000LocationTypeUser\000";
    static const int32_t values[] = {
        ADCOMLocationType_LocationTypeInvalid,
        ADCOMLocationType_LocationTypeGps,
        ADCOMLocationType_LocationTypeIp,
        ADCOMLocationType_LocationTypeUser,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMLocationType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMLocationType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMLocationType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMLocationType_LocationTypeInvalid:
    case ADCOMLocationType_LocationTypeGps:
    case ADCOMLocationType_LocationTypeIp:
    case ADCOMLocationType_LocationTypeUser:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMMediaRating

GPBEnumDescriptor *ADCOMMediaRating_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MediaRatingInvalid\000MediaRatingAllAudienc"
        "es\000MediaRatingEveryoneOverAge12\000MediaRat"
        "ingMatureAudiences\000";
    static const int32_t values[] = {
        ADCOMMediaRating_MediaRatingInvalid,
        ADCOMMediaRating_MediaRatingAllAudiences,
        ADCOMMediaRating_MediaRatingEveryoneOverAge12,
        ADCOMMediaRating_MediaRatingMatureAudiences,
    };
    static const char *extraTextFormatInfo = "\001\002e\346\350\344\343\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMMediaRating)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMMediaRating_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMMediaRating_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMMediaRating_MediaRatingInvalid:
    case ADCOMMediaRating_MediaRatingAllAudiences:
    case ADCOMMediaRating_MediaRatingEveryoneOverAge12:
    case ADCOMMediaRating_MediaRatingMatureAudiences:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMNativeDataAssetType

GPBEnumDescriptor *ADCOMNativeDataAssetType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NativeDataAssetTypeInvalid\000NativeDataAss"
        "etTypeSponsored\000NativeDataAssetTypeDesc\000"
        "NativeDataAssetTypeRating\000NativeDataAsse"
        "tTypeLikes\000NativeDataAssetTypeDownloads\000"
        "NativeDataAssetTypePrice\000NativeDataAsset"
        "TypeSalePrice\000NativeDataAssetTypePhone\000N"
        "ativeDataAssetTypeAddress\000NativeDataAsse"
        "tTypeDesc2\000NativeDataAssetTypeDisplayURL"
        "\000NativeDataAssetTypeCtaText\000";
    static const int32_t values[] = {
        ADCOMNativeDataAssetType_NativeDataAssetTypeInvalid,
        ADCOMNativeDataAssetType_NativeDataAssetTypeSponsored,
        ADCOMNativeDataAssetType_NativeDataAssetTypeDesc,
        ADCOMNativeDataAssetType_NativeDataAssetTypeRating,
        ADCOMNativeDataAssetType_NativeDataAssetTypeLikes,
        ADCOMNativeDataAssetType_NativeDataAssetTypeDownloads,
        ADCOMNativeDataAssetType_NativeDataAssetTypePrice,
        ADCOMNativeDataAssetType_NativeDataAssetTypeSalePrice,
        ADCOMNativeDataAssetType_NativeDataAssetTypePhone,
        ADCOMNativeDataAssetType_NativeDataAssetTypeAddress,
        ADCOMNativeDataAssetType_NativeDataAssetTypeDesc2,
        ADCOMNativeDataAssetType_NativeDataAssetTypeDisplayURL,
        ADCOMNativeDataAssetType_NativeDataAssetTypeCtaText,
    };
    static const char *extraTextFormatInfo = "\001\013f\344\345\344\347\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMNativeDataAssetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMNativeDataAssetType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMNativeDataAssetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMNativeDataAssetType_NativeDataAssetTypeInvalid:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeSponsored:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeDesc:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeRating:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeLikes:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeDownloads:
    case ADCOMNativeDataAssetType_NativeDataAssetTypePrice:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeSalePrice:
    case ADCOMNativeDataAssetType_NativeDataAssetTypePhone:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeAddress:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeDesc2:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeDisplayURL:
    case ADCOMNativeDataAssetType_NativeDataAssetTypeCtaText:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMNativeImageAssetType

GPBEnumDescriptor *ADCOMNativeImageAssetType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NativeImageAssetTypeInvalid\000NativeImageA"
        "ssetTypeIconImage\000NativeImageAssetTypeMa"
        "inImage\000";
    static const int32_t values[] = {
        ADCOMNativeImageAssetType_NativeImageAssetTypeInvalid,
        ADCOMNativeImageAssetType_NativeImageAssetTypeIconImage,
        ADCOMNativeImageAssetType_NativeImageAssetTypeMainImage,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMNativeImageAssetType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMNativeImageAssetType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMNativeImageAssetType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMNativeImageAssetType_NativeImageAssetTypeInvalid:
    case ADCOMNativeImageAssetType_NativeImageAssetTypeIconImage:
    case ADCOMNativeImageAssetType_NativeImageAssetTypeMainImage:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMOS

GPBEnumDescriptor *ADCOMOS_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "OsInvalid\000OsAndroid\000OsIos\000";
    static const int32_t values[] = {
        ADCOMOS_OsInvalid,
        ADCOMOS_OsAndroid,
        ADCOMOS_OsIos,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMOS)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMOS_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMOS_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMOS_OsInvalid:
    case ADCOMOS_OsAndroid:
    case ADCOMOS_OsIos:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMPlaybackCessationMode

GPBEnumDescriptor *ADCOMPlaybackCessationMode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlaybackCessationModeInvalid\000PlaybackCes"
        "sationModeOnVideoCompletion\000PlaybackCess"
        "ationModeOnLeavingViewport\000PlaybackCessa"
        "tionModeOnLeavingViewportContinuesFloati"
        "ng\000";
    static const int32_t values[] = {
        ADCOMPlaybackCessationMode_PlaybackCessationModeInvalid,
        ADCOMPlaybackCessationMode_PlaybackCessationModeOnVideoCompletion,
        ADCOMPlaybackCessationMode_PlaybackCessationModeOnLeavingViewport,
        ADCOMPlaybackCessationMode_PlaybackCessationModeOnLeavingViewportContinuesFloating,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMPlaybackCessationMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMPlaybackCessationMode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMPlaybackCessationMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMPlaybackCessationMode_PlaybackCessationModeInvalid:
    case ADCOMPlaybackCessationMode_PlaybackCessationModeOnVideoCompletion:
    case ADCOMPlaybackCessationMode_PlaybackCessationModeOnLeavingViewport:
    case ADCOMPlaybackCessationMode_PlaybackCessationModeOnLeavingViewportContinuesFloating:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMPlaybackMethod

GPBEnumDescriptor *ADCOMPlaybackMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlaybackMethodInvalid\000PlaybackMethodOnPa"
        "geLoadSoundOn\000PlaybackMethodOnPageLoadSo"
        "undOff\000PlaybackMethodOnClickSoundOn\000Play"
        "backMethodOnMouseOverSoundOn\000PlaybackMet"
        "hodOnEnteringViewportSoundOn\000PlaybackMet"
        "hodOnEnteringViewportSoundOff\000";
    static const int32_t values[] = {
        ADCOMPlaybackMethod_PlaybackMethodInvalid,
        ADCOMPlaybackMethod_PlaybackMethodOnPageLoadSoundOn,
        ADCOMPlaybackMethod_PlaybackMethodOnPageLoadSoundOff,
        ADCOMPlaybackMethod_PlaybackMethodOnClickSoundOn,
        ADCOMPlaybackMethod_PlaybackMethodOnMouseOverSoundOn,
        ADCOMPlaybackMethod_PlaybackMethodOnEnteringViewportSoundOn,
        ADCOMPlaybackMethod_PlaybackMethodOnEnteringViewportSoundOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMPlaybackMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMPlaybackMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMPlaybackMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMPlaybackMethod_PlaybackMethodInvalid:
    case ADCOMPlaybackMethod_PlaybackMethodOnPageLoadSoundOn:
    case ADCOMPlaybackMethod_PlaybackMethodOnPageLoadSoundOff:
    case ADCOMPlaybackMethod_PlaybackMethodOnClickSoundOn:
    case ADCOMPlaybackMethod_PlaybackMethodOnMouseOverSoundOn:
    case ADCOMPlaybackMethod_PlaybackMethodOnEnteringViewportSoundOn:
    case ADCOMPlaybackMethod_PlaybackMethodOnEnteringViewportSoundOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMPlacementPosition

GPBEnumDescriptor *ADCOMPlacementPosition_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PlacementPositionInvalid\000PlacementPositi"
        "onAboveTheFold\000PlacementPositionLocked\000P"
        "lacementPositionBelowTheFold\000PlacementPo"
        "sitionHeader\000PlacementPositionFooter\000Pla"
        "cementPositionSidebar\000PlacementPositionF"
        "ullscreen\000";
    static const int32_t values[] = {
        ADCOMPlacementPosition_PlacementPositionInvalid,
        ADCOMPlacementPosition_PlacementPositionAboveTheFold,
        ADCOMPlacementPosition_PlacementPositionLocked,
        ADCOMPlacementPosition_PlacementPositionBelowTheFold,
        ADCOMPlacementPosition_PlacementPositionHeader,
        ADCOMPlacementPosition_PlacementPositionFooter,
        ADCOMPlacementPosition_PlacementPositionSidebar,
        ADCOMPlacementPosition_PlacementPositionFullscreen,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMPlacementPosition)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMPlacementPosition_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMPlacementPosition_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMPlacementPosition_PlacementPositionInvalid:
    case ADCOMPlacementPosition_PlacementPositionAboveTheFold:
    case ADCOMPlacementPosition_PlacementPositionLocked:
    case ADCOMPlacementPosition_PlacementPositionBelowTheFold:
    case ADCOMPlacementPosition_PlacementPositionHeader:
    case ADCOMPlacementPosition_PlacementPositionFooter:
    case ADCOMPlacementPosition_PlacementPositionSidebar:
    case ADCOMPlacementPosition_PlacementPositionFullscreen:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMProductionQuality

GPBEnumDescriptor *ADCOMProductionQuality_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ProductionQualityInvalid\000ProductionQuali"
        "tyProfessionallyProduced\000ProductionQuali"
        "tyProsumer\000ProductionQualityUserGenerate"
        "d\000";
    static const int32_t values[] = {
        ADCOMProductionQuality_ProductionQualityInvalid,
        ADCOMProductionQuality_ProductionQualityProfessionallyProduced,
        ADCOMProductionQuality_ProductionQualityProsumer,
        ADCOMProductionQuality_ProductionQualityUserGenerated,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMProductionQuality)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMProductionQuality_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMProductionQuality_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMProductionQuality_ProductionQualityInvalid:
    case ADCOMProductionQuality_ProductionQualityProfessionallyProduced:
    case ADCOMProductionQuality_ProductionQualityProsumer:
    case ADCOMProductionQuality_ProductionQualityUserGenerated:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMSizeUnit

GPBEnumDescriptor *ADCOMSizeUnit_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "SizeUnitInvalid\000SizeUnitDips\000SizeUnitInc"
        "hes\000SizeUnitCentimeters\000";
    static const int32_t values[] = {
        ADCOMSizeUnit_SizeUnitInvalid,
        ADCOMSizeUnit_SizeUnitDips,
        ADCOMSizeUnit_SizeUnitInches,
        ADCOMSizeUnit_SizeUnitCentimeters,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMSizeUnit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMSizeUnit_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMSizeUnit_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMSizeUnit_SizeUnitInvalid:
    case ADCOMSizeUnit_SizeUnitDips:
    case ADCOMSizeUnit_SizeUnitInches:
    case ADCOMSizeUnit_SizeUnitCentimeters:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMVideoCreativeType

GPBEnumDescriptor *ADCOMVideoCreativeType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VideoCreativeTypeInvalid\000VideoCreativeTy"
        "peVast10\000VideoCreativeTypeVast20\000VideoCr"
        "eativeTypeVast30\000VideoCreativeTypeVastWr"
        "apper10\000VideoCreativeTypeVastWrapper20\000V"
        "ideoCreativeTypeVastWrapper30\000VideoCreat"
        "iveTypeVast40\000VideoCreativeTypeVastWrapp"
        "er40\000VideoCreativeTypeVast41\000VideoCreati"
        "veTypeVastWrapper41\000";
    static const int32_t values[] = {
        ADCOMVideoCreativeType_VideoCreativeTypeInvalid,
        ADCOMVideoCreativeType_VideoCreativeTypeVast10,
        ADCOMVideoCreativeType_VideoCreativeTypeVast20,
        ADCOMVideoCreativeType_VideoCreativeTypeVast30,
        ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper10,
        ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper20,
        ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper30,
        ADCOMVideoCreativeType_VideoCreativeTypeVast40,
        ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper40,
        ADCOMVideoCreativeType_VideoCreativeTypeVast41,
        ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper41,
    };
    static const char *extraTextFormatInfo = "\n\001e\350\344\344\201\201\000\002e\350\344\344\201\201\000\003e\350\344\344\201\201\000\004e\350\344\344\347\201\201\000\005e\350\344\344\347\201\201\000\006e\350\344\344\347\201\201\000\007e\350\344\344\201\201\000\010e\350\344\344\347\201\201\000\te\350\344\344\201\201\000\ne\350\344\344\347\201\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMVideoCreativeType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMVideoCreativeType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMVideoCreativeType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMVideoCreativeType_VideoCreativeTypeInvalid:
    case ADCOMVideoCreativeType_VideoCreativeTypeVast10:
    case ADCOMVideoCreativeType_VideoCreativeTypeVast20:
    case ADCOMVideoCreativeType_VideoCreativeTypeVast30:
    case ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper10:
    case ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper20:
    case ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper30:
    case ADCOMVideoCreativeType_VideoCreativeTypeVast40:
    case ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper40:
    case ADCOMVideoCreativeType_VideoCreativeTypeVast41:
    case ADCOMVideoCreativeType_VideoCreativeTypeVastWrapper41:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ADCOMVideoPlacementType

GPBEnumDescriptor *ADCOMVideoPlacementType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VideoPlacementTypeInvalid\000VideoPlacement"
        "TypeInStream\000VideoPlacementTypeInBanner\000"
        "VideoPlacementTypeInArticle\000VideoPlaceme"
        "ntTypeInFeed\000VideoPlacementTypeInterstit"
        "ial\000";
    static const int32_t values[] = {
        ADCOMVideoPlacementType_VideoPlacementTypeInvalid,
        ADCOMVideoPlacementType_VideoPlacementTypeInStream,
        ADCOMVideoPlacementType_VideoPlacementTypeInBanner,
        ADCOMVideoPlacementType_VideoPlacementTypeInArticle,
        ADCOMVideoPlacementType_VideoPlacementTypeInFeed,
        ADCOMVideoPlacementType_VideoPlacementTypeInterstitial,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ADCOMVideoPlacementType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ADCOMVideoPlacementType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ADCOMVideoPlacementType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ADCOMVideoPlacementType_VideoPlacementTypeInvalid:
    case ADCOMVideoPlacementType_VideoPlacementTypeInStream:
    case ADCOMVideoPlacementType_VideoPlacementTypeInBanner:
    case ADCOMVideoPlacementType_VideoPlacementTypeInArticle:
    case ADCOMVideoPlacementType_VideoPlacementTypeInFeed:
    case ADCOMVideoPlacementType_VideoPlacementTypeInterstitial:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ADCOMContext

@implementation ADCOMContext

@dynamic hasApp, app;
@dynamic hasDevice, device;
@dynamic hasRegs, regs;
@dynamic hasRestrictions, restrictions;
@dynamic hasUser, user;

typedef struct ADCOMContext__storage_ {
  uint32_t _has_storage_[1];
  ADCOMContext_App *app;
  ADCOMContext_Device *device;
  ADCOMContext_Regs *regs;
  ADCOMContext_Restrictions *restrictions;
  ADCOMContext_User *user;
} ADCOMContext__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "app",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_App),
        .number = ADCOMContext_FieldNumber_App,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext__storage_, app),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "device",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Device),
        .number = ADCOMContext_FieldNumber_Device,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext__storage_, device),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "regs",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Regs),
        .number = ADCOMContext_FieldNumber_Regs,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext__storage_, regs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "restrictions",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Restrictions),
        .number = ADCOMContext_FieldNumber_Restrictions,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext__storage_, restrictions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_User),
        .number = ADCOMContext_FieldNumber_User,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMContext__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMContext_App

@implementation ADCOMContext_App

@dynamic id_p;
@dynamic name;
@dynamic hasPub, pub;
@dynamic hasContent, content;
@dynamic domain;
@dynamic catArray, catArray_Count;
@dynamic sectcatArray, sectcatArray_Count;
@dynamic pagecatArray, pagecatArray_Count;
@dynamic cattax;
@dynamic privpolicy;
@dynamic keywords;
@dynamic bundle;
@dynamic storeid;
@dynamic storeurl;
@dynamic ver;
@dynamic paid;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_App__storage_ {
  uint32_t _has_storage_[1];
  ADCOMCategoryTaxonomy cattax;
  NSString *id_p;
  NSString *name;
  ADCOMContext_App_Publisher *pub;
  ADCOMContext_App_Content *content;
  NSString *domain;
  NSMutableArray *catArray;
  NSMutableArray *sectcatArray;
  NSMutableArray *pagecatArray;
  NSString *keywords;
  NSString *bundle;
  NSString *storeid;
  NSString *storeurl;
  NSString *ver;
  NSMutableArray *extArray;
} ADCOMContext_App__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pub",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_App_Publisher),
        .number = ADCOMContext_App_FieldNumber_Pub,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, pub),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_App_Content),
        .number = ADCOMContext_App_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Domain,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "catArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_CatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, catArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sectcatArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_SectcatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, sectcatArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pagecatArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_PagecatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, pagecatArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMContext_App_FieldNumber_Cattax,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "privpolicy",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Privpolicy,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "keywords",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Keywords,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, keywords),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundle",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Bundle,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, bundle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storeid",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Storeid,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, storeid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storeurl",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Storeurl,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, storeurl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ver",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Ver,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, ver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "paid",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_FieldNumber_Paid,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_App_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_App class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_App__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_App_Cattax_RawValue(ADCOMContext_App *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Cattax_RawValue(ADCOMContext_App *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_App_Publisher

@implementation ADCOMContext_App_Publisher

@dynamic id_p;
@dynamic name;
@dynamic domain;
@dynamic catArray, catArray_Count;
@dynamic cattax;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_App_Publisher__storage_ {
  uint32_t _has_storage_[1];
  ADCOMCategoryTaxonomy cattax;
  NSString *id_p;
  NSString *name;
  NSString *domain;
  NSMutableArray *catArray;
  NSMutableArray *extArray;
} ADCOMContext_App_Publisher__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Publisher_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Publisher__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Publisher_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Publisher__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Publisher_FieldNumber_Domain,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Publisher__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "catArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Publisher_FieldNumber_CatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Publisher__storage_, catArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMContext_App_Publisher_FieldNumber_Cattax,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Publisher__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_App_Publisher_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Publisher__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_App_Publisher class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_App_Publisher__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext_App)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_App_Publisher_Cattax_RawValue(ADCOMContext_App_Publisher *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Publisher descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Publisher_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Publisher_Cattax_RawValue(ADCOMContext_App_Publisher *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Publisher descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Publisher_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_App_Content

@implementation ADCOMContext_App_Content

@dynamic id_p;
@dynamic episode;
@dynamic title;
@dynamic series;
@dynamic season;
@dynamic artist;
@dynamic genre;
@dynamic album;
@dynamic isrc;
@dynamic URL;
@dynamic catArray, catArray_Count;
@dynamic cattax;
@dynamic prodq;
@dynamic context;
@dynamic rating;
@dynamic urating;
@dynamic mrating;
@dynamic keywords;
@dynamic live;
@dynamic srcrel;
@dynamic len;
@dynamic lang;
@dynamic embed;
@dynamic hasProducer, producer;
@dynamic dataArray, dataArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_App_Content__storage_ {
  uint32_t _has_storage_[1];
  uint32_t episode;
  ADCOMCategoryTaxonomy cattax;
  ADCOMProductionQuality prodq;
  ADCOMContentContext context;
  ADCOMMediaRating mrating;
  uint32_t srcrel;
  uint32_t len;
  NSString *id_p;
  NSString *title;
  NSString *series;
  NSString *season;
  NSString *artist;
  NSString *genre;
  NSString *album;
  NSString *isrc;
  NSString *URL;
  NSMutableArray *catArray;
  NSString *rating;
  NSString *urating;
  NSString *keywords;
  NSString *lang;
  ADCOMContext_App_Content_Producer *producer;
  NSMutableArray *dataArray;
  NSMutableArray *extArray;
} ADCOMContext_App_Content__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "episode",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Episode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, episode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Title,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "series",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Series,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, series),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "season",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Season,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, season),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "artist",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Artist,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, artist),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "genre",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Genre,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, genre),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "album",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Album,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, album),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isrc",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Isrc,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, isrc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_URL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "catArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_CatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, catArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMContext_App_Content_FieldNumber_Cattax,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "prodq",
        .dataTypeSpecific.enumDescFunc = ADCOMProductionQuality_EnumDescriptor,
        .number = ADCOMContext_App_Content_FieldNumber_Prodq,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, prodq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "context",
        .dataTypeSpecific.enumDescFunc = ADCOMContentContext_EnumDescriptor,
        .number = ADCOMContext_App_Content_FieldNumber_Context,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, context),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "rating",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Rating,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, rating),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "urating",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Urating,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, urating),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mrating",
        .dataTypeSpecific.enumDescFunc = ADCOMMediaRating_EnumDescriptor,
        .number = ADCOMContext_App_Content_FieldNumber_Mrating,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, mrating),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "keywords",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Keywords,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, keywords),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "live",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Live,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "srcrel",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Srcrel,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, srcrel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Len,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lang",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Lang,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, lang),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "embed",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_FieldNumber_Embed,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "producer",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_App_Content_Producer),
        .number = ADCOMContext_App_Content_FieldNumber_Producer,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, producer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Data),
        .number = ADCOMContext_App_Content_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_App_Content_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_App_Content class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_App_Content__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\n!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext_App)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_App_Content_Cattax_RawValue(ADCOMContext_App_Content *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Content_Cattax_RawValue(ADCOMContext_App_Content *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMContext_App_Content_Prodq_RawValue(ADCOMContext_App_Content *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Prodq];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Content_Prodq_RawValue(ADCOMContext_App_Content *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Prodq];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMContext_App_Content_Context_RawValue(ADCOMContext_App_Content *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Context];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Content_Context_RawValue(ADCOMContext_App_Content *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Context];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMContext_App_Content_Mrating_RawValue(ADCOMContext_App_Content *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Mrating];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Content_Mrating_RawValue(ADCOMContext_App_Content *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_FieldNumber_Mrating];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_App_Content_Producer

@implementation ADCOMContext_App_Content_Producer

@dynamic id_p;
@dynamic name;
@dynamic domain;
@dynamic catArray, catArray_Count;
@dynamic cattax;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_App_Content_Producer__storage_ {
  uint32_t _has_storage_[1];
  ADCOMCategoryTaxonomy cattax;
  NSString *id_p;
  NSString *name;
  NSString *domain;
  NSMutableArray *catArray;
  NSMutableArray *extArray;
} ADCOMContext_App_Content_Producer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_Producer_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content_Producer__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_Producer_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content_Producer__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_Producer_FieldNumber_Domain,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content_Producer__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "catArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_App_Content_Producer_FieldNumber_CatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content_Producer__storage_, catArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMContext_App_Content_Producer_FieldNumber_Cattax,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content_Producer__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_App_Content_Producer_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_App_Content_Producer__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_App_Content_Producer class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_App_Content_Producer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext_App_Content)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_App_Content_Producer_Cattax_RawValue(ADCOMContext_App_Content_Producer *message) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content_Producer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_Producer_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_App_Content_Producer_Cattax_RawValue(ADCOMContext_App_Content_Producer *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_App_Content_Producer descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_App_Content_Producer_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_Data

@implementation ADCOMContext_Data

@dynamic id_p;
@dynamic name;
@dynamic segmentArray, segmentArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_Data__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  NSMutableArray *segmentArray;
  NSMutableArray *extArray;
} ADCOMContext_Data__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Data_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_Data__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Data_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_Data__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "segmentArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Data_Segment),
        .number = ADCOMContext_Data_FieldNumber_SegmentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Data__storage_, segmentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_Data_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Data__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_Data class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_Data__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMContext_Data_Segment

@implementation ADCOMContext_Data_Segment

@dynamic id_p;
@dynamic name;
@dynamic value;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_Data_Segment__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  NSString *value;
  NSMutableArray *extArray;
} ADCOMContext_Data_Segment__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Data_Segment_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_Data_Segment__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Data_Segment_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_Data_Segment__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Data_Segment_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_Data_Segment__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_Data_Segment_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Data_Segment__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_Data_Segment class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_Data_Segment__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext_Data)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMContext_Geo

@implementation ADCOMContext_Geo

@dynamic type;
@dynamic lat;
@dynamic lon;
@dynamic accur;
@dynamic lastfix;
@dynamic ipserv;
@dynamic country;
@dynamic region;
@dynamic metro;
@dynamic city;
@dynamic zip;
@dynamic utcoffset;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_Geo__storage_ {
  uint32_t _has_storage_[1];
  ADCOMLocationType type;
  float lat;
  float lon;
  uint32_t accur;
  ADCOMIpLocationService ipserv;
  int32_t utcoffset;
  NSString *country;
  NSString *region;
  NSString *metro;
  NSString *city;
  NSString *zip;
  NSMutableArray *extArray;
  uint64_t lastfix;
} ADCOMContext_Geo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMLocationType_EnumDescriptor,
        .number = ADCOMContext_Geo_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lat",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Lat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, lat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lon",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Lon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, lon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "accur",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Accur,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, accur),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastfix",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Lastfix,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, lastfix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ipserv",
        .dataTypeSpecific.enumDescFunc = ADCOMIpLocationService_EnumDescriptor,
        .number = ADCOMContext_Geo_FieldNumber_Ipserv,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, ipserv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Country,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "region",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Region,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, region),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "metro",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Metro,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, metro),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_City,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "zip",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Zip,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, zip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "utcoffset",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Geo_FieldNumber_Utcoffset,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, utcoffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_Geo_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Geo__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_Geo class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_Geo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_Geo_Type_RawValue(ADCOMContext_Geo *message) {
  GPBDescriptor *descriptor = [ADCOMContext_Geo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Geo_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_Geo_Type_RawValue(ADCOMContext_Geo *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_Geo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Geo_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMContext_Geo_Ipserv_RawValue(ADCOMContext_Geo *message) {
  GPBDescriptor *descriptor = [ADCOMContext_Geo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Geo_FieldNumber_Ipserv];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_Geo_Ipserv_RawValue(ADCOMContext_Geo *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_Geo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Geo_FieldNumber_Ipserv];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_Device

@implementation ADCOMContext_Device

@dynamic type;
@dynamic ua;
@dynamic ifa;
@dynamic dnt;
@dynamic lmt;
@dynamic make;
@dynamic model;
@dynamic os;
@dynamic osv;
@dynamic hwv;
@dynamic h;
@dynamic w;
@dynamic ppi;
@dynamic pxratio;
@dynamic js;
@dynamic lang;
@dynamic ip;
@dynamic ipv6;
@dynamic xff;
@dynamic iptr;
@dynamic carrier;
@dynamic mccmnc;
@dynamic mccmncsim;
@dynamic contype;
@dynamic geofetch;
@dynamic hasGeo, geo;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_Device__storage_ {
  uint32_t _has_storage_[1];
  ADCOMDeviceType type;
  ADCOMOS os;
  uint32_t h;
  uint32_t w;
  uint32_t ppi;
  float pxratio;
  ADCOMConnectionType contype;
  NSString *ua;
  NSString *ifa;
  NSString *make;
  NSString *model;
  NSString *osv;
  NSString *hwv;
  NSString *lang;
  NSString *ip;
  NSString *ipv6;
  NSString *xff;
  NSString *carrier;
  NSString *mccmnc;
  NSString *mccmncsim;
  ADCOMContext_Geo *geo;
  NSMutableArray *extArray;
} ADCOMContext_Device__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMDeviceType_EnumDescriptor,
        .number = ADCOMContext_Device_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ua",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Ua,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, ua),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ifa",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Ifa,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, ifa),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dnt",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Dnt,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "lmt",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Lmt,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "make",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Make,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, make),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Model,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "os",
        .dataTypeSpecific.enumDescFunc = ADCOMOS_EnumDescriptor,
        .number = ADCOMContext_Device_FieldNumber_Os,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, os),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "osv",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Osv,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, osv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hwv",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Hwv,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, hwv),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_H,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_W,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ppi",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Ppi,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, ppi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pxratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Pxratio,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, pxratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "js",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Js,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "lang",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Lang,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, lang),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Ip,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ipv6",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Ipv6,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, ipv6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xff",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Xff,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, xff),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iptr",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Iptr,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "carrier",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Carrier,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, carrier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mccmnc",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Mccmnc,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, mccmnc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mccmncsim",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Mccmncsim,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, mccmncsim),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contype",
        .dataTypeSpecific.enumDescFunc = ADCOMConnectionType_EnumDescriptor,
        .number = ADCOMContext_Device_FieldNumber_Contype,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, contype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "geofetch",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Device_FieldNumber_Geofetch,
        .hasIndex = 28,
        .offset = 29,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "geo",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Geo),
        .number = ADCOMContext_Device_FieldNumber_Geo,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, geo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_Device_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Device__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_Device class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_Device__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_Device_Type_RawValue(ADCOMContext_Device *message) {
  GPBDescriptor *descriptor = [ADCOMContext_Device descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Device_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_Device_Type_RawValue(ADCOMContext_Device *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_Device descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Device_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMContext_Device_Os_RawValue(ADCOMContext_Device *message) {
  GPBDescriptor *descriptor = [ADCOMContext_Device descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Device_FieldNumber_Os];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_Device_Os_RawValue(ADCOMContext_Device *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_Device descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Device_FieldNumber_Os];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMContext_Device_Contype_RawValue(ADCOMContext_Device *message) {
  GPBDescriptor *descriptor = [ADCOMContext_Device descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Device_FieldNumber_Contype];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_Device_Contype_RawValue(ADCOMContext_Device *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_Device descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Device_FieldNumber_Contype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_Regs

@implementation ADCOMContext_Regs

@dynamic coppa;
@dynamic gdpr;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_Regs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *extArray;
} ADCOMContext_Regs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "coppa",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Regs_FieldNumber_Coppa,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gdpr",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Regs_FieldNumber_Gdpr,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_Regs_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Regs__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_Regs class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_Regs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMContext_Restrictions

@implementation ADCOMContext_Restrictions

@dynamic bcatArray, bcatArray_Count;
@dynamic cattax;
@dynamic badvArray, badvArray_Count;
@dynamic bappArray, bappArray_Count;
@dynamic battrArray, battrArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_Restrictions__storage_ {
  uint32_t _has_storage_[1];
  ADCOMCategoryTaxonomy cattax;
  NSMutableArray *bcatArray;
  NSMutableArray *badvArray;
  NSMutableArray *bappArray;
  GPBEnumArray *battrArray;
  NSMutableArray *extArray;
} ADCOMContext_Restrictions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bcatArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Restrictions_FieldNumber_BcatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Restrictions__storage_, bcatArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMContext_Restrictions_FieldNumber_Cattax,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_Restrictions__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "badvArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Restrictions_FieldNumber_BadvArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Restrictions__storage_, badvArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bappArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_Restrictions_FieldNumber_BappArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Restrictions__storage_, bappArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "battrArray",
        .dataTypeSpecific.enumDescFunc = ADCOMCreativeAttribute_EnumDescriptor,
        .number = ADCOMContext_Restrictions_FieldNumber_BattrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Restrictions__storage_, battrArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_Restrictions_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_Restrictions__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_Restrictions class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_Restrictions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMContext_Restrictions_Cattax_RawValue(ADCOMContext_Restrictions *message) {
  GPBDescriptor *descriptor = [ADCOMContext_Restrictions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Restrictions_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMContext_Restrictions_Cattax_RawValue(ADCOMContext_Restrictions *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMContext_Restrictions descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMContext_Restrictions_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMContext_User

@implementation ADCOMContext_User

@dynamic id_p;
@dynamic buyeruid;
@dynamic yob;
@dynamic gender;
@dynamic keywords;
@dynamic consent;
@dynamic hasGeo, geo;
@dynamic dataArray, dataArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMContext_User__storage_ {
  uint32_t _has_storage_[1];
  uint32_t yob;
  NSString *id_p;
  NSString *buyeruid;
  NSString *gender;
  NSString *keywords;
  NSString *consent;
  ADCOMContext_Geo *geo;
  NSMutableArray *dataArray;
  NSMutableArray *extArray;
} ADCOMContext_User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_User_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buyeruid",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_User_FieldNumber_Buyeruid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, buyeruid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "yob",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_User_FieldNumber_Yob,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, yob),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gender",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_User_FieldNumber_Gender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, gender),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keywords",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_User_FieldNumber_Keywords,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, keywords),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "consent",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMContext_User_FieldNumber_Consent,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, consent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "geo",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Geo),
        .number = ADCOMContext_User_FieldNumber_Geo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, geo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMContext_Data),
        .number = ADCOMContext_User_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, dataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMContext_User_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMContext_User__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMContext_User class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMContext_User__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMContext)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMPlacement

@implementation ADCOMPlacement

@dynamic tagid;
@dynamic ssai;
@dynamic sdk;
@dynamic sdkver;
@dynamic reward;
@dynamic bcatArray, bcatArray_Count;
@dynamic cattax;
@dynamic badvArray, badvArray_Count;
@dynamic bappArray, bappArray_Count;
@dynamic battrArray, battrArray_Count;
@dynamic wlangArray, wlangArray_Count;
@dynamic secure;
@dynamic admx;
@dynamic curlx;
@dynamic hasDisplay, display;
@dynamic hasVideo, video;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ssai;
  ADCOMCategoryTaxonomy cattax;
  NSString *tagid;
  NSString *sdk;
  NSString *sdkver;
  NSMutableArray *bcatArray;
  NSMutableArray *badvArray;
  NSMutableArray *bappArray;
  GPBEnumArray *battrArray;
  NSMutableArray *wlangArray;
  ADCOMPlacement_DisplayPlacement *display;
  ADCOMPlacement_VideoPlacement *video;
  NSMutableArray *extArray;
} ADCOMPlacement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagid",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Tagid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, tagid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ssai",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Ssai,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, ssai),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sdk",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Sdk,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, sdk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sdkver",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Sdkver,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, sdkver),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reward",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Reward,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bcatArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_BcatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, bcatArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMPlacement_FieldNumber_Cattax,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "badvArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_BadvArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, badvArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bappArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_BappArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, bappArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "battrArray",
        .dataTypeSpecific.enumDescFunc = ADCOMCreativeAttribute_EnumDescriptor,
        .number = ADCOMPlacement_FieldNumber_BattrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, battrArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "wlangArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_WlangArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, wlangArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secure",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Secure,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "admx",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Admx,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "curlx",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_FieldNumber_Curlx,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "display",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement),
        .number = ADCOMPlacement_FieldNumber_Display,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, display),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_VideoPlacement),
        .number = ADCOMPlacement_FieldNumber_Video,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMPlacement_Cattax_RawValue(ADCOMPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_Cattax_RawValue(ADCOMPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMPlacement_DisplayPlacement

@implementation ADCOMPlacement_DisplayPlacement

@dynamic pos;
@dynamic instl;
@dynamic topframe;
@dynamic ifrbustArray, ifrbustArray_Count;
@dynamic clktype;
@dynamic ampren;
@dynamic ptype;
@dynamic context;
@dynamic mimeArray, mimeArray_Count;
@dynamic apiArray, apiArray_Count;
@dynamic ctypeArray, ctypeArray_Count;
@dynamic w;
@dynamic h;
@dynamic unit;
@dynamic priv;
@dynamic displayfmtArray, displayfmtArray_Count;
@dynamic hasNativefmt, nativefmt;
@dynamic eventArray, eventArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement__storage_ {
  uint32_t _has_storage_[1];
  ADCOMPlacementPosition pos;
  ADCOMClickType clktype;
  uint32_t ampren;
  ADCOMDisplayPlacementType ptype;
  ADCOMDisplayContextType context;
  uint32_t w;
  uint32_t h;
  ADCOMSizeUnit unit;
  NSMutableArray *ifrbustArray;
  NSMutableArray *mimeArray;
  GPBEnumArray *apiArray;
  GPBEnumArray *ctypeArray;
  NSMutableArray *displayfmtArray;
  ADCOMPlacement_DisplayPlacement_NativeFormat *nativefmt;
  NSMutableArray *eventArray;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pos",
        .dataTypeSpecific.enumDescFunc = ADCOMPlacementPosition_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Pos,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, pos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "instl",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Instl,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "topframe",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Topframe,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ifrbustArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_IfrbustArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, ifrbustArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clktype",
        .dataTypeSpecific.enumDescFunc = ADCOMClickType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Clktype,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, clktype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ampren",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Ampren,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, ampren),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ptype",
        .dataTypeSpecific.enumDescFunc = ADCOMDisplayPlacementType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Ptype,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, ptype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "context",
        .dataTypeSpecific.enumDescFunc = ADCOMDisplayContextType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Context,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, context),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mimeArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_MimeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, mimeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiArray",
        .dataTypeSpecific.enumDescFunc = ADCOMApiFramework_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_ApiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, apiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ctypeArray",
        .dataTypeSpecific.enumDescFunc = ADCOMDisplayCreativeType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_CtypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, ctypeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_W,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_H,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = ADCOMSizeUnit_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Unit,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "priv",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Priv,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "displayfmtArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_DisplayFormat),
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_DisplayfmtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, displayfmtArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nativefmt",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat),
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_Nativefmt,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, nativefmt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eventArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_EventSpec),
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_EventArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, eventArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMPlacement_DisplayPlacement_Pos_RawValue(ADCOMPlacement_DisplayPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Pos];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_Pos_RawValue(ADCOMPlacement_DisplayPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Pos];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_DisplayPlacement_Clktype_RawValue(ADCOMPlacement_DisplayPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Clktype];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_Clktype_RawValue(ADCOMPlacement_DisplayPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Clktype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_DisplayPlacement_Ptype_RawValue(ADCOMPlacement_DisplayPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Ptype];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_Ptype_RawValue(ADCOMPlacement_DisplayPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Ptype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_DisplayPlacement_Context_RawValue(ADCOMPlacement_DisplayPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Context];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_Context_RawValue(ADCOMPlacement_DisplayPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Context];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_DisplayPlacement_Unit_RawValue(ADCOMPlacement_DisplayPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_Unit_RawValue(ADCOMPlacement_DisplayPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMPlacement_DisplayPlacement_DisplayFormat

@implementation ADCOMPlacement_DisplayPlacement_DisplayFormat

@dynamic w;
@dynamic h;
@dynamic wratio;
@dynamic hratio;
@dynamic expdirArray, expdirArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t w;
  uint32_t h;
  uint32_t wratio;
  uint32_t hratio;
  GPBEnumArray *expdirArray;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_DisplayFormat_FieldNumber_W,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_DisplayFormat_FieldNumber_H,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_DisplayFormat_FieldNumber_Wratio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_, wratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_DisplayFormat_FieldNumber_Hratio,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_, hratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "expdirArray",
        .dataTypeSpecific.enumDescFunc = ADCOMExpandableDirection_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_DisplayFormat_FieldNumber_ExpdirArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_, expdirArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_DisplayFormat_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_DisplayFormat class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_DisplayFormat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMPlacement_DisplayPlacement_NativeFormat

@implementation ADCOMPlacement_DisplayPlacement_NativeFormat

@dynamic assetArray, assetArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_NativeFormat__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *assetArray;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_NativeFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "assetArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_FieldNumber_AssetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat__storage_, assetArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_NativeFormat class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_NativeFormat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat

@implementation ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat

@dynamic id_p;
@dynamic req;
@dynamic hasTitle, title;
@dynamic hasImg, img;
@dynamic hasVideo, video;
@dynamic hasData_p, data_p;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat *title;
  ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat *img;
  ADCOMPlacement_VideoPlacement *video;
  ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat *data_p;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "req",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_Req,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "img",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_Img,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_VideoPlacement),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_Video,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_Data_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat

@implementation ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat

@dynamic len;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat__storage_ {
  uint32_t _has_storage_[1];
  uint32_t len;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat_FieldNumber_Len,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_TitleAssetFormat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat

@implementation ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat

@dynamic type;
@dynamic mimeArray, mimeArray_Count;
@dynamic w;
@dynamic h;
@dynamic wmin;
@dynamic hmin;
@dynamic wratio;
@dynamic hratio;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_ {
  uint32_t _has_storage_[1];
  ADCOMNativeImageAssetType type;
  uint32_t w;
  uint32_t h;
  uint32_t wmin;
  uint32_t hmin;
  uint32_t wratio;
  uint32_t hratio;
  NSMutableArray *mimeArray;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMNativeImageAssetType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mimeArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_MimeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, mimeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_W,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_H,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wmin",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Wmin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, wmin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hmin",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Hmin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, hmin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Wratio,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, wratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Hratio,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, hratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_Type_RawValue(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_Type_RawValue(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_ImageAssetFormat_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat

@implementation ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat

@dynamic type;
@dynamic len;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat__storage_ {
  uint32_t _has_storage_[1];
  ADCOMNativeDataAssetType type;
  uint32_t len;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMNativeDataAssetType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_FieldNumber_Len,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_Type_RawValue(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_Type_RawValue(ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_NativeFormat_AssetFormat_DataAssetFormat_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMPlacement_DisplayPlacement_EventSpec

@implementation ADCOMPlacement_DisplayPlacement_EventSpec

@dynamic type;
@dynamic methodArray, methodArray_Count;
@dynamic apiArray, apiArray_Count;
@dynamic jstrkArray, jstrkArray_Count;
@dynamic wjs;
@dynamic pxtrkArray, pxtrkArray_Count;
@dynamic wpx;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_DisplayPlacement_EventSpec__storage_ {
  uint32_t _has_storage_[1];
  ADCOMEventType type;
  GPBEnumArray *methodArray;
  GPBEnumArray *apiArray;
  NSMutableArray *jstrkArray;
  NSMutableArray *pxtrkArray;
  NSMutableArray *extArray;
} ADCOMPlacement_DisplayPlacement_EventSpec__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMEventType_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "methodArray",
        .dataTypeSpecific.enumDescFunc = ADCOMEventTrackingMethod_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_MethodArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_, methodArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "apiArray",
        .dataTypeSpecific.enumDescFunc = ADCOMApiFramework_EnumDescriptor,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_ApiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_, apiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "jstrkArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_JstrkArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_, jstrkArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wjs",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_Wjs,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pxtrkArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_PxtrkArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_, pxtrkArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wpx",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_Wpx,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_DisplayPlacement_EventSpec class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_DisplayPlacement_EventSpec__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_DisplayPlacement)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMPlacement_DisplayPlacement_EventSpec_Type_RawValue(ADCOMPlacement_DisplayPlacement_EventSpec *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement_EventSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_DisplayPlacement_EventSpec_Type_RawValue(ADCOMPlacement_DisplayPlacement_EventSpec *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_DisplayPlacement_EventSpec descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_DisplayPlacement_EventSpec_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMPlacement_VideoPlacement

@implementation ADCOMPlacement_VideoPlacement

@dynamic ptype;
@dynamic pos;
@dynamic delay;
@dynamic skip;
@dynamic skipmin;
@dynamic skipafter;
@dynamic playmethod;
@dynamic playend;
@dynamic clktype;
@dynamic mimeArray, mimeArray_Count;
@dynamic apiArray, apiArray_Count;
@dynamic ctypeArray, ctypeArray_Count;
@dynamic w;
@dynamic h;
@dynamic unit;
@dynamic mindur;
@dynamic maxdur;
@dynamic maxext;
@dynamic minbitr;
@dynamic maxbitr;
@dynamic deliveryArray, deliveryArray_Count;
@dynamic maxseq;
@dynamic linear;
@dynamic boxing;
@dynamic compArray, compArray_Count;
@dynamic comptypeArray, comptypeArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_VideoPlacement__storage_ {
  uint32_t _has_storage_[1];
  ADCOMVideoPlacementType ptype;
  ADCOMPlacementPosition pos;
  int32_t delay;
  uint32_t skipmin;
  uint32_t skipafter;
  ADCOMPlaybackMethod playmethod;
  ADCOMPlaybackCessationMode playend;
  ADCOMClickType clktype;
  uint32_t w;
  uint32_t h;
  ADCOMSizeUnit unit;
  uint32_t mindur;
  uint32_t maxdur;
  int32_t maxext;
  uint32_t minbitr;
  uint32_t maxbitr;
  uint32_t maxseq;
  ADCOMLinearityMode linear;
  NSMutableArray *mimeArray;
  GPBEnumArray *apiArray;
  GPBEnumArray *ctypeArray;
  GPBEnumArray *deliveryArray;
  NSMutableArray *compArray;
  GPBEnumArray *comptypeArray;
  NSMutableArray *extArray;
} ADCOMPlacement_VideoPlacement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ptype",
        .dataTypeSpecific.enumDescFunc = ADCOMVideoPlacementType_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Ptype,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, ptype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "pos",
        .dataTypeSpecific.enumDescFunc = ADCOMPlacementPosition_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Pos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, pos),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "delay",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Delay,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, delay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "skip",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Skip,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "skipmin",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Skipmin,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, skipmin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "skipafter",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Skipafter,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, skipafter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "playmethod",
        .dataTypeSpecific.enumDescFunc = ADCOMPlaybackMethod_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Playmethod,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, playmethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "playend",
        .dataTypeSpecific.enumDescFunc = ADCOMPlaybackCessationMode_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Playend,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, playend),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "clktype",
        .dataTypeSpecific.enumDescFunc = ADCOMClickType_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Clktype,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, clktype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mimeArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_MimeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, mimeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiArray",
        .dataTypeSpecific.enumDescFunc = ADCOMApiFramework_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_ApiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, apiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "ctypeArray",
        .dataTypeSpecific.enumDescFunc = ADCOMVideoCreativeType_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_CtypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, ctypeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_W,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_H,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = ADCOMSizeUnit_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Unit,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mindur",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Mindur,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, mindur),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxdur",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Maxdur,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, maxdur),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxext",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Maxext,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, maxext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minbitr",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Minbitr,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, minbitr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxbitr",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Maxbitr,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, maxbitr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deliveryArray",
        .dataTypeSpecific.enumDescFunc = ADCOMDeliveryMethod_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_DeliveryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, deliveryArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "maxseq",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Maxseq,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, maxseq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "linear",
        .dataTypeSpecific.enumDescFunc = ADCOMLinearityMode_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Linear,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, linear),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "boxing",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_Boxing,
        .hasIndex = 20,
        .offset = 21,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "compArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_VideoPlacement_Companion),
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_CompArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, compArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "comptypeArray",
        .dataTypeSpecific.enumDescFunc = ADCOMCompanionType_EnumDescriptor,
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_ComptypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, comptypeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_VideoPlacement_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_VideoPlacement class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_VideoPlacement__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMPlacement_VideoPlacement_Ptype_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Ptype];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Ptype_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Ptype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_VideoPlacement_Pos_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Pos];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Pos_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Pos];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_VideoPlacement_Playmethod_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Playmethod];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Playmethod_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Playmethod];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_VideoPlacement_Playend_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Playend];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Playend_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Playend];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_VideoPlacement_Clktype_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Clktype];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Clktype_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Clktype];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_VideoPlacement_Unit_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Unit_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMPlacement_VideoPlacement_Linear_RawValue(ADCOMPlacement_VideoPlacement *message) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Linear];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMPlacement_VideoPlacement_Linear_RawValue(ADCOMPlacement_VideoPlacement *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMPlacement_VideoPlacement descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMPlacement_VideoPlacement_FieldNumber_Linear];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMPlacement_VideoPlacement_Companion

@implementation ADCOMPlacement_VideoPlacement_Companion

@dynamic id_p;
@dynamic vcm;
@dynamic hasDisplay, display;
@dynamic extArray, extArray_Count;

typedef struct ADCOMPlacement_VideoPlacement_Companion__storage_ {
  uint32_t _has_storage_[1];
  uint32_t vcm;
  NSString *id_p;
  ADCOMPlacement_DisplayPlacement *display;
  NSMutableArray *extArray;
} ADCOMPlacement_VideoPlacement_Companion__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_Companion_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement_Companion__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "vcm",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMPlacement_VideoPlacement_Companion_FieldNumber_Vcm,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement_Companion__storage_, vcm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "display",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMPlacement_DisplayPlacement),
        .number = ADCOMPlacement_VideoPlacement_Companion_FieldNumber_Display,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement_Companion__storage_, display),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMPlacement_VideoPlacement_Companion_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMPlacement_VideoPlacement_Companion__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMPlacement_VideoPlacement_Companion class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMPlacement_VideoPlacement_Companion__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMPlacement_VideoPlacement)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd

@implementation ADCOMAd

@dynamic id_p;
@dynamic adomainArray, adomainArray_Count;
@dynamic bundleArray, bundleArray_Count;
@dynamic iurl;
@dynamic catArray, catArray_Count;
@dynamic cattax;
@dynamic lang;
@dynamic secure;
@dynamic mrating;
@dynamic init_p;
@dynamic lastmod;
@dynamic hasDisplay, display;
@dynamic hasVideo, video;
@dynamic hasAudit, audit;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd__storage_ {
  uint32_t _has_storage_[1];
  ADCOMCategoryTaxonomy cattax;
  ADCOMMediaRating mrating;
  NSString *id_p;
  NSMutableArray *adomainArray;
  NSMutableArray *bundleArray;
  NSString *iurl;
  NSMutableArray *catArray;
  NSString *lang;
  NSString *init_p;
  NSString *lastmod;
  ADCOMAd_Display *display;
  ADCOMAd_Video *video;
  ADCOMAd_Audit *audit;
  NSMutableArray *extArray;
} ADCOMAd__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adomainArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_AdomainArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, adomainArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_BundleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, bundleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iurl",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_Iurl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, iurl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "catArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_CatArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, catArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cattax",
        .dataTypeSpecific.enumDescFunc = ADCOMCategoryTaxonomy_EnumDescriptor,
        .number = ADCOMAd_FieldNumber_Cattax,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, cattax),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "lang",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_Lang,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, lang),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secure",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_Secure,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mrating",
        .dataTypeSpecific.enumDescFunc = ADCOMMediaRating_EnumDescriptor,
        .number = ADCOMAd_FieldNumber_Mrating,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, mrating),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "init_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_Init_p,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, init_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastmod",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_FieldNumber_Lastmod,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, lastmod),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "display",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display),
        .number = ADCOMAd_FieldNumber_Display,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, display),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Video),
        .number = ADCOMAd_FieldNumber_Video,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audit",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Audit),
        .number = ADCOMAd_FieldNumber_Audit,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, audit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMAd_Cattax_RawValue(ADCOMAd *message) {
  GPBDescriptor *descriptor = [ADCOMAd descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_FieldNumber_Cattax];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Cattax_RawValue(ADCOMAd *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_FieldNumber_Cattax];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMAd_Mrating_RawValue(ADCOMAd *message) {
  GPBDescriptor *descriptor = [ADCOMAd descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_FieldNumber_Mrating];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Mrating_RawValue(ADCOMAd *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_FieldNumber_Mrating];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMAd_Event

@implementation ADCOMAd_Event

@dynamic type;
@dynamic method;
@dynamic apiArray, apiArray_Count;
@dynamic URL;
@dynamic cdata, cdata_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Event__storage_ {
  uint32_t _has_storage_[1];
  ADCOMEventType type;
  ADCOMEventTrackingMethod method;
  GPBEnumArray *apiArray;
  NSString *URL;
  NSMutableDictionary *cdata;
  NSMutableArray *extArray;
} ADCOMAd_Event__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMEventType_EnumDescriptor,
        .number = ADCOMAd_Event_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Event__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "method",
        .dataTypeSpecific.enumDescFunc = ADCOMEventTrackingMethod_EnumDescriptor,
        .number = ADCOMAd_Event_FieldNumber_Method,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Event__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "apiArray",
        .dataTypeSpecific.enumDescFunc = ADCOMApiFramework_EnumDescriptor,
        .number = ADCOMAd_Event_FieldNumber_ApiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Event__storage_, apiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Event_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMAd_Event__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cdata",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Event_FieldNumber_Cdata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Event__storage_, cdata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Event_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Event__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Event class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Event__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMAd_Event_Type_RawValue(ADCOMAd_Event *message) {
  GPBDescriptor *descriptor = [ADCOMAd_Event descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Event_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Event_Type_RawValue(ADCOMAd_Event *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd_Event descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Event_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t ADCOMAd_Event_Method_RawValue(ADCOMAd_Event *message) {
  GPBDescriptor *descriptor = [ADCOMAd_Event descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Event_FieldNumber_Method];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Event_Method_RawValue(ADCOMAd_Event *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd_Event descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Event_FieldNumber_Method];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMAd_Display

@implementation ADCOMAd_Display

@dynamic mimeArray, mimeArray_Count;
@dynamic apiArray, apiArray_Count;
@dynamic typeArray, typeArray_Count;
@dynamic w;
@dynamic h;
@dynamic wratio;
@dynamic hratio;
@dynamic adm;
@dynamic curl;
@dynamic hasBanner, banner;
@dynamic hasNative, native;
@dynamic eventArray, eventArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display__storage_ {
  uint32_t _has_storage_[1];
  uint32_t w;
  uint32_t h;
  uint32_t wratio;
  uint32_t hratio;
  NSMutableArray *mimeArray;
  GPBEnumArray *apiArray;
  GPBEnumArray *typeArray;
  NSString *adm;
  NSString *curl;
  ADCOMAd_Display_Banner *banner;
  ADCOMAd_Display_Native *native;
  NSMutableArray *eventArray;
  NSMutableArray *extArray;
} ADCOMAd_Display__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mimeArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_MimeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, mimeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiArray",
        .dataTypeSpecific.enumDescFunc = ADCOMApiFramework_EnumDescriptor,
        .number = ADCOMAd_Display_FieldNumber_ApiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, apiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "typeArray",
        .dataTypeSpecific.enumDescFunc = ADCOMDisplayCreativeType_EnumDescriptor,
        .number = ADCOMAd_Display_FieldNumber_TypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, typeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_W,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_H,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_Wratio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, wratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hratio",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_Hratio,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, hratio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "adm",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_Adm,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, adm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "curl",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_FieldNumber_Curl,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, curl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "banner",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Banner),
        .number = ADCOMAd_Display_FieldNumber_Banner,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, banner),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "native",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native),
        .number = ADCOMAd_Display_FieldNumber_Native,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, native),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eventArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Event),
        .number = ADCOMAd_Display_FieldNumber_EventArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, eventArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Banner

@implementation ADCOMAd_Display_Banner

@dynamic img;
@dynamic link;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Banner__storage_ {
  uint32_t _has_storage_[1];
  NSString *img;
  NSString *link;
  NSMutableArray *extArray;
} ADCOMAd_Display_Banner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "img",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Banner_FieldNumber_Img,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Banner__storage_, img),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "link",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Banner_FieldNumber_Link,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Banner__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Banner_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Banner__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Banner class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Banner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Native

@implementation ADCOMAd_Display_Native

@dynamic hasLink, link;
@dynamic assetArray, assetArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native__storage_ {
  uint32_t _has_storage_[1];
  ADCOMAd_Display_Native_LinkAsset *link;
  NSMutableArray *assetArray;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "link",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_LinkAsset),
        .number = ADCOMAd_Display_Native_FieldNumber_Link,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_Asset),
        .number = ADCOMAd_Display_Native_FieldNumber_AssetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native__storage_, assetArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Native_LinkAsset

@implementation ADCOMAd_Display_Native_LinkAsset

@dynamic URL;
@dynamic urlfb;
@dynamic trkrArray, trkrArray_Count;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native_LinkAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *URL;
  NSString *urlfb;
  NSMutableArray *trkrArray;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native_LinkAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_LinkAsset_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_LinkAsset__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "urlfb",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_LinkAsset_FieldNumber_Urlfb,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_LinkAsset__storage_, urlfb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trkrArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_LinkAsset_FieldNumber_TrkrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_LinkAsset__storage_, trkrArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_LinkAsset_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_LinkAsset__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native_LinkAsset class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native_LinkAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display_Native)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Native_Asset

@implementation ADCOMAd_Display_Native_Asset

@dynamic id_p;
@dynamic req;
@dynamic hasTitle, title;
@dynamic hasImage, image;
@dynamic hasVideo, video;
@dynamic hasData_p, data_p;
@dynamic hasLink, link;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native_Asset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  ADCOMAd_Display_Native_Asset_TitleAsset *title;
  ADCOMAd_Display_Native_Asset_ImageAsset *image;
  ADCOMAd_Display_Native_Asset_VideoAsset *video;
  ADCOMAd_Display_Native_Asset_DataAsset *data_p;
  ADCOMAd_Display_Native_LinkAsset *link;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native_Asset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "req",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Req,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "title",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_Asset_TitleAsset),
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Title,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_Asset_ImageAsset),
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Image,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "video",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_Asset_VideoAsset),
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Video,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, video),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_Asset_DataAsset),
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Data_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "link",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd_Display_Native_LinkAsset),
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_Link,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_Asset_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native_Asset class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native_Asset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display_Native)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Native_Asset_TitleAsset

@implementation ADCOMAd_Display_Native_Asset_TitleAsset

@dynamic text;
@dynamic len;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native_Asset_TitleAsset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t len;
  NSString *text;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native_Asset_TitleAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_TitleAsset_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_TitleAsset__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_TitleAsset_FieldNumber_Len,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_TitleAsset__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_Asset_TitleAsset_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_TitleAsset__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native_Asset_TitleAsset class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native_Asset_TitleAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display_Native_Asset)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Native_Asset_ImageAsset

@implementation ADCOMAd_Display_Native_Asset_ImageAsset

@dynamic URL;
@dynamic w;
@dynamic h;
@dynamic type;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native_Asset_ImageAsset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t w;
  uint32_t h;
  ADCOMNativeImageAssetType type;
  NSString *URL;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native_Asset_ImageAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_ImageAsset__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "w",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_W,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_ImageAsset__storage_, w),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "h",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_H,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_ImageAsset__storage_, h),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMNativeImageAssetType_EnumDescriptor,
        .number = ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_ImageAsset__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_ImageAsset__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native_Asset_ImageAsset class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native_Asset_ImageAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display_Native_Asset)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMAd_Display_Native_Asset_ImageAsset_Type_RawValue(ADCOMAd_Display_Native_Asset_ImageAsset *message) {
  GPBDescriptor *descriptor = [ADCOMAd_Display_Native_Asset_ImageAsset descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Display_Native_Asset_ImageAsset_Type_RawValue(ADCOMAd_Display_Native_Asset_ImageAsset *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd_Display_Native_Asset_ImageAsset descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Display_Native_Asset_ImageAsset_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMAd_Display_Native_Asset_VideoAsset

@implementation ADCOMAd_Display_Native_Asset_VideoAsset

@dynamic adm;
@dynamic curl;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native_Asset_VideoAsset__storage_ {
  uint32_t _has_storage_[1];
  NSString *adm;
  NSString *curl;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native_Asset_VideoAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "adm",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_VideoAsset_FieldNumber_Adm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_VideoAsset__storage_, adm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "curl",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_VideoAsset_FieldNumber_Curl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_VideoAsset__storage_, curl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_Asset_VideoAsset_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_VideoAsset__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native_Asset_VideoAsset class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native_Asset_VideoAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display_Native_Asset)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Display_Native_Asset_DataAsset

@implementation ADCOMAd_Display_Native_Asset_DataAsset

@dynamic value;
@dynamic len;
@dynamic type;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Display_Native_Asset_DataAsset__storage_ {
  uint32_t _has_storage_[1];
  uint32_t len;
  ADCOMNativeDataAssetType type;
  NSString *value;
  NSMutableArray *extArray;
} ADCOMAd_Display_Native_Asset_DataAsset__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_DataAsset_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_DataAsset__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Display_Native_Asset_DataAsset_FieldNumber_Len,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_DataAsset__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = ADCOMNativeDataAssetType_EnumDescriptor,
        .number = ADCOMAd_Display_Native_Asset_DataAsset_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_DataAsset__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Display_Native_Asset_DataAsset_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Display_Native_Asset_DataAsset__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Display_Native_Asset_DataAsset class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Display_Native_Asset_DataAsset__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd_Display_Native_Asset)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMAd_Display_Native_Asset_DataAsset_Type_RawValue(ADCOMAd_Display_Native_Asset_DataAsset *message) {
  GPBDescriptor *descriptor = [ADCOMAd_Display_Native_Asset_DataAsset descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Display_Native_Asset_DataAsset_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Display_Native_Asset_DataAsset_Type_RawValue(ADCOMAd_Display_Native_Asset_DataAsset *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd_Display_Native_Asset_DataAsset descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Display_Native_Asset_DataAsset_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ADCOMAd_Video

@implementation ADCOMAd_Video

@dynamic mimeArray, mimeArray_Count;
@dynamic apiArray, apiArray_Count;
@dynamic typeArray, typeArray_Count;
@dynamic adm;
@dynamic curl;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Video__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *mimeArray;
  GPBEnumArray *apiArray;
  GPBEnumArray *typeArray;
  NSString *adm;
  NSString *curl;
  NSMutableArray *extArray;
} ADCOMAd_Video__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mimeArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Video_FieldNumber_MimeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Video__storage_, mimeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apiArray",
        .dataTypeSpecific.enumDescFunc = ADCOMApiFramework_EnumDescriptor,
        .number = ADCOMAd_Video_FieldNumber_ApiArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Video__storage_, apiArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "typeArray",
        .dataTypeSpecific.enumDescFunc = ADCOMVideoCreativeType_EnumDescriptor,
        .number = ADCOMAd_Video_FieldNumber_TypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Video__storage_, typeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "adm",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Video_FieldNumber_Adm,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Video__storage_, adm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "curl",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Video_FieldNumber_Curl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Video__storage_, curl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Video_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Video__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Video class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Video__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ADCOMAd_Audit

@implementation ADCOMAd_Audit

@dynamic status;
@dynamic feedbackArray, feedbackArray_Count;
@dynamic init_p;
@dynamic lastmod;
@dynamic hasCorr, corr;
@dynamic extArray, extArray_Count;

typedef struct ADCOMAd_Audit__storage_ {
  uint32_t _has_storage_[1];
  ADCOMAuditStatusCode status;
  NSMutableArray *feedbackArray;
  NSString *init_p;
  NSString *lastmod;
  ADCOMAd *corr;
  NSMutableArray *extArray;
} ADCOMAd_Audit__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ADCOMAuditStatusCode_EnumDescriptor,
        .number = ADCOMAd_Audit_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ADCOMAd_Audit__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "feedbackArray",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Audit_FieldNumber_FeedbackArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Audit__storage_, feedbackArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "init_p",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Audit_FieldNumber_Init_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ADCOMAd_Audit__storage_, init_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastmod",
        .dataTypeSpecific.className = NULL,
        .number = ADCOMAd_Audit_FieldNumber_Lastmod,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ADCOMAd_Audit__storage_, lastmod),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "corr",
        .dataTypeSpecific.className = GPBStringifySymbol(ADCOMAd),
        .number = ADCOMAd_Audit_FieldNumber_Corr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ADCOMAd_Audit__storage_, corr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = ADCOMAd_Audit_FieldNumber_ExtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ADCOMAd_Audit__storage_, extArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ADCOMAd_Audit class]
                                     rootClass:[ADCOMAdcomRoot class]
                                          file:ADCOMAdcomRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ADCOMAd_Audit__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ADCOMAd)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ADCOMAd_Audit_Status_RawValue(ADCOMAd_Audit *message) {
  GPBDescriptor *descriptor = [ADCOMAd_Audit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Audit_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetADCOMAd_Audit_Status_RawValue(ADCOMAd_Audit *message, int32_t value) {
  GPBDescriptor *descriptor = [ADCOMAd_Audit descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ADCOMAd_Audit_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
